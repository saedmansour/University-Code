
package BuckToRoy;

require Exporter;

use lib ".";

our @ISA = qw(Exporter);

our @EXPORT = qw(
  BuckToRoy
);


# gets buckwalter analysis as input and generates analyses in roy's format using
# mona's collapse
#################################
# 3.6.05
# 1. normal procedure that should be taken:
# splitTXT | preprocessPOS (generates XML) | processClitics (or processFUNC)
# I don't know what is the difference between processFUNC and processClitics
# as the documentation for both is copied without change :)
# Anyway processFunc uses a rules files func-subst2.list which processClitics doesn't use
# The best thing to do is to understand what those files does and make a nice script
# doing those stuff nicely.
################################
# 3.6.05
# 2. meanwhile as I can't run the process* files, I'll use buck-bt and buck-at from the corpus
# update - buck-at can't be used as it's a kind of cheating, so i'll try to
#			seperate the clitics somehow :)
##########################################################################
# 1.10.05
# buck_to_roy takes a buckwalter analyses file and sgm file, and generates
# word and analysis output in roy format after collapse.
# updates:	sgm file used to determine end of sentences to match mona's definition
#			extend the collapse so everything is collapsed
#run:
#perl buck_to_roy.pl ../DARAB_ALL/ATB1_v2_0/data/pos/before-treebank/20000715_AFP_ARB.0001.txt ../DARAB_ALL/ATB1_v2_0/data/sgm/20000715_AFP_ARB.0001.sgm
# atb1-test-before-treebank.txt atb1-test-sgm.txt > atb1-test-analyses-roy.txt
# atb1-learn-before-treebank.txt atb1-learn-sgm.txt > atb1-learn-analyses-roy.txt
# UMAAH_UM.ARB_20010721-e.0018.xml.txt UMAAH_UM.ARB_20010721-e.0018.sgm > ummah.txt
# 3 ../data/atb3-dev-buckv1.0.fix > ../data/atb3-dev-analyses-roy
###################################################################
use strict;

use lib "..";
use lib "../../scripts";

use atb_common;
use perl_common;


#####################################################################################



######################### parse command line #####################
=old
if ($#ARGV < 0 || $ARGV[0] eq "-help") {
  print STDERR <<"EOF";

Usage: $0 [options] buckout [output]
buckout       amibuous file generated by buckwalter morpho analyzer v1.0
output        the name of the output file, if not specified
              will be written to buckout-roy..., including errors files
OPTIONS:
-a part       which atb part
-l            with lemmas
-v            with vowels
-oov          print oov instead of NNP for oov words
-ct           with collapse tags
-cc           with collapse chars
-cp						replace puncs with pp... so that MT wont go crazy
-help         print this message

EOF
  exit;
}

=cut


sub BuckToRoy{
# my $param = shift;

############ setting the defaults

my $outfile = "";
my $include_lemmas = 0;
my $include_vowels = 0;
my $do_collapse_tags = 1;
my $do_collapse_chars = 0;
my $do_replace_puncs = 0;
my $use_nnp_heur = 1;
my $include_patterns = 0;
my $buckout = "";

my $whichatb = 2;

############## parsing parameters


my $ok =0;

#my @param = split(" ",$param);

=old
while (@param) {
  my $arg = shift @param;

  ### -l
  if ($arg eq "-l") {
    $include_lemmas = 1;
  }
  ### -a
  elsif ($arg eq "-a") {
    $whichatb = shift @param;
  }
  ### -v
  elsif ($arg eq "-v") {
    $include_vowels = 1;
  }
  ### -oov
  elsif ($arg eq "-oov") {
    $use_nnp_heur = 0;
  }
  ### -cc
  elsif ($arg eq "-cc") {
    $do_collapse_chars = 1;
  }
  ### -ct
  elsif ($arg eq "-ct") {
    $do_collapse_tags = 1;
  }
  elsif ($arg eq "-rp") {
    $do_replace_puncs = 1;
  }
  ### -p
  elsif ($arg eq "-p") {
    $include_patterns = 1;
  }
  ### not an option - we got to the required parameters
  else {
    die "Unknown option '$arg'; type $0 -help for information\n"
      if ($arg =~ /^-/);
    $buckout = $arg;
    die "$buckout was not found\n" unless -e $buckout;
	
	if (@param == 1){
		$outfile = shift @param;
		#die "$outfile was not found\n" unless -e $outfile;
	}
	else{
		$outfile = "$buckout-roy_";
		if ($include_lemmas){
			#$outfile.="+l";
		}
		else{
			#$outfile.="-l";
		}
		if ($include_vowels){
			#$outfile.="+v";
		}
		else{
			#$outfile.="-v";
		}
		if ($do_collapse_tags){
			$outfile.="+ct";
		}
		else{
			$outfile.="-ct";
		}
		if ($do_collapse_chars){
			$outfile.="+cc";
		}
		else{
			$outfile.="-cc";
		}
		if ($include_patterns){
			#$outfile.="+p";
		}
		else{
			#$outfile.="-p";
		}
	}
	
  } 
}

if (not @param){
	$ok = 1;
}

unless ($ok) {
  #die "Too many arguments ; type $0 -help for information\n" if (scalar(@ARGV)>3);
  #die "Too few arguments ;  type $0 -help for information\n" if (scalar(@ARGV)<3); 
  die "wrong arguments ;  type $0 -help for information\n"; 
}

=cut
#open(BUCKBT, "perl remove-INDEX.pl < $buckout | perl splitTXT.pl|") or die "can't open $buckout: $!";

my $buckout = shift;
my @buckout = split("\n",$buckout);
@buckout = grep(!/INDEX:/,@buckout);
print STDERR "in BuckToRoy:\n";
print STDERR join("\n",@buckout);
print STDERR "\n";
@buckout = SplitTXT(\@buckout);

#open(BUCKBT, "< $beforetb") or die "can't open $beforetb: $!";
#open(LOG, ">$outfile\.log") or die "can't create $outfile\.log: $!";
#open(OUT, ">$outfile") or die "can't open file $outfile: $!";

#statistics variables
my $numanalyses = 0;			#number of different solutions of the words after the collapse
my $numuncollapsed = 0;		#number of uncollapsed solutions/analyses
my $numambiguouswords = 0;	#number of words that has ambiguous solutions in the sense that MT can't map tags to morphs
my $numstrings = 0;			  #number of strings
my $numarabicstrings = 0;				#number of arabic words
my $numotherstrings = 0;				#number of arabic words
my $numunknown = 0;				#unanalyzed words
my $sentencenum = 1;			#numbe of sentence currently being analyzed
my $numnotchosensol = 0;		#number of words with solutions but no one was chosen
my %numanalyses_numwords = ();	#how many words had n collapsed analyses
my %numsegments_numanal = ();	#how many analyses had n given number of segments
my %numsegments_numwords = ();	#how many different segments a word had


#my %tags = ();
my %morphtags = ();
my %tagmorphs = ();


my $NUMTAG = "NUM";
if ($do_collapse_tags){
	$NUMTAG = "CD";
}

my $to_print = "";

	my ($bucklength,$bucktokennum) = (0 , 0); my @bucktokens=();


	while(@buckout){
		$_ = shift @buckout;
		#chop;
		
		if (/^#\s*$/){
			print STDERR "Finished processing sentence: $sentencenum\r";
			$to_print .=  "$_\n";
			$sentencenum++;
		}
		elsif (/INPUT STRING:\s*(.+)/){
		
		my $arword = $1;
		$arword =~ s/\s//g;
		
		#read next, should be lookup word, or comment
		$_ = shift @buckout;
		chop;
		
		$numstrings++;		#this is total number
		my ($isarabic, $word) = (0,"");
		
		if (/LOOK-UP WORD:\s+(.+)$/) {	
				$word = $1;
				$word =~ s/\s//g;
				#read comment
				$_ = shift @buckout;
				if (!/Comment:/){
					print STDERR "didnt find Comment: after $_\n";
				}
				$isarabic = 1;
		}
		else{	$word = $arword	};
		
		
		my $worddf = $word;
		if ($do_collapse_chars){
			$worddf = DEF_FORMAT($word); #word with defualt format
		}
		
		
		push(@bucktokens,$word);
		
		$bucklength+=length $word;
		$bucktokennum++;	#this is current line of buck
		my $isokfornewline = 0;
		
	
		if ($isarabic) {
			if ($do_collapse_chars){ 
			 	$to_print .=  REMOVEMARKSWORD($word),"\n";
			}else{
			 		$to_print .= $word,"\n";
			}
			$numarabicstrings++;
		}
		#print OUT $word,"\n";	$numarabicwords++;}
		else {
			$to_print .= HEX_TO_CHAR($word),"\n";
			$numotherstrings++;
		}
		
		my @solutions = (); my ($num_sol,$ischosensol) = (0,0);
		my $isendsen = 0;
		while(($_=shift @buckout)=~/^\s*\*?\s*SOLUTION \d+:\s*(\S+)\s+(\S+\s+)?(\S+)\s*$/){
			my ($vword, $lemma, $analysis) = ($1,$2,$3);
			$analysis =~ s/\s//g;
			if ($analysis =~ /(NUM)|(PUNC)/ and $analysis !~ /[A-Za-z][^\/]*\/NUM/){
				$analysis =~ /^(.+)\/(.+)$/;
				my ($morph,$tag) = ($1,$2);
				#print STDERR "$analysis --- $morph --- $tag\n";
				if ($tag eq "PUNC"){
					#print OUT "\t\t\(PUNC $morph)\n";
					if ($do_replace_puncs){
						$solutions[$num_sol] .= "(PUNC ".REMOVEMARKSPUNC($morph).")";
					}
					else{
						$solutions[$num_sol] .= "(PUNC ".REMOVEMARKSPUNC($morph).")";
					}
					$tagmorphs{"PUNC"}{$morph} =1;
				}			
				
				if ($tag eq "PUNC" and $morph =~ [0-9]){
					print STDERR "unexpected: $tag --- $morph\n";
				}
				
				if ($tag eq "NUM"){
					#print OUT "\t\t($NUMTAG $morph)\n";
					$solutions[$num_sol] .= "($NUMTAG $morph)";
					$tagmorphs{$NUMTAG}{$morph} =1;			
				}
				goto AFTERSEP;		
			}
			
			
			#if ($whichatb != 1){
			#7.12.07.11.40
			#always do this
				$analysis=~s/(.+\+)ap(\/NSUFF_FEM_SG\+.+\/POSS_PRON.+)$/$1at$2/;
			#}
			
			#remove trailing space
			$lemma =~ s/\s+$//;
			
			$ischosensol=1 if $_=~/\*\s*SOLUTION/;			
						
			#do automatic seperation taken from processClitics
			my @tagmorphs = ();
			
			$analysis = MATCH_ANALYSIS($analysis);
			
			PERFORM_AUTO_SEP($analysis,\@tagmorphs,$whichatb);
			
			my $lastl = "";
			my $lemma_assigned = 0;
			foreach my $tagmorph (@tagmorphs){
				$tagmorph =~ /^\((.+) (.+)\)$/;
				my ($tag,$morph) = ($1,$2);
				$morph =~ s/\(nll\)//;
				$morph =~ s/\(null\)//;
				if ($morph=~/^~[aiueo~`FNK+]+$/){
					$morph =~ s/\~/\Q$lastl\E/;
					#print LOG "Exchanged ~ at sentence #$sentencenum: $tagmorph\n";
				}
				
				my $pattern = "";
				if ($tag ne "CD" and $tag ne "NUM"){
					$pattern = GET_VOWELS_PATTERN($morph);
				}
				
				my $mtag = MATCH_TAG($tag);
				
				if (!$include_vowels and $mtag ne 'NON_ARABIC' and $mtag ne "LATIN" and $mtag ne 'PUNC' and $morph!~/\d/ ){
					#remove vowels
					$morph =~ s/[aiueo~`FNK+]//g;
				}
				
				my $cmtag = $mtag;
				if ($do_collapse_tags){
					$cmtag = $COLLAPSEHASH{$mtag};
					if (length($cmtag)==0){
						print STDERR "NOCOLLAPSE\t$tagmorph\n";
						$numuncollapsed++;
					}
				}
			
				if ( ( ($do_collapse_tags and STR_PIN_LIST($cmtag,\@SIGTAGSCOLL) )
						or (!$do_collapse_tags and STR_PIN_LIST($cmtag,\@SIGTAGS) ) )
					and $morph!~/\d/ ){
					
					if ($include_lemmas and $lemma){
						$lemma =~ s/\[|\]//g;
						$lemma =~ s/_//g;
						#$lemma =~ s/[aiueo~`FNK+_]//g;
						$cmtag = $lemma."+".$cmtag;
						$lemma_assigned = 1;
					}
					if ($include_patterns and $pattern){
						$cmtag = $pattern."+".$cmtag;
					}
					
				}
							
				if (length($morph)==0 or length($cmtag)==0){
					#print LOG "EMPTY MORPH/TAG\tsentence #$sentencenum: $tagmorph\n";
				}
				
				#if (!$isarabic){
				#	$morph = REMOVEMARKSPUNC($morph);
				#}
				
				if ($do_collapse_chars){
					$morph = REMOVEMARKS($morph,$isarabic);
				}
				
				$solutions[$num_sol] .= "($cmtag $morph) ";
				$tagmorphs{$cmtag}{$morph} =1;
				$lastl = substr($morph,-1);
				
			}
			
			
AFTERSEP:
			$num_sol++;
			#eat the glossary line
			$_ = shift @buckout;
			last if (/^s*$/);
			if (!/\(GLOSS\)/ and $isarabic){
				print STDERR "GLOSS missing\n";
			}
		}
		
		if ($_ =~ /^\s*#\s*$/){
			$isendsen = 1;
		}
		
		#$numnotchosensol++,print ERROR "NO CHOSEN SOL $word\n" if !$ischosensol and $num_sol>0 ;
		
		#remove duplicates
		my %saw = ();
		@solutions = grep(!$saw{$_}++, @solutions);
		
		#check is there is ambigious solutions in @solutions in the sense of MT
		if (!$include_vowels and check_ambig_sol(@solutions)){
			$numambiguouswords++;
			#print LOG "AMBIGSOL\tword: ($word), solutions: ". join("\t",@solutions) . "\n";
		}
			
		
		#print the solutions
		foreach my $solution (@solutions) {			
			if ($solution!~/\(.+?\s+\)\s*$/){
				#update the number of words with the current number of segments
				my @morphs = ($solution =~ /\(.+? (.+?)\)/g);
				$numsegments_numanal{@morphs}++ if $isarabic;
				#chop $solution;
				#remove trailing spaces if present
				$solution =~ s/\s+$//;
				$to_print .= "\t$solution\n" ;
			}
			else{
				#print LOG "EMPTY_MORPHEME_SOLUTION\t#$sentencenum: word - [$word], solution [$solution]\n";
			}
		}
		
		$numanalyses+=@solutions;
		
		#update number of words with the current number of solutions 
		$numanalyses_numwords{@solutions}++ if $isarabic;
		
		#update number of words with the current number of different segmentations
		$numsegments_numwords{num_diff_seg(@solutions)}++ if $isarabic;
		
		#assume words without solutions as NNP or PUNC sometimes
		#changed to XXX
		if ($num_sol==0) {
			$numsegments_numanal{1}++ if $isarabic;
			if (   $worddf =~ /[\?\"\.\,\!\:\;\+\%\(\)\[\]\_]/
				or $worddf =~ /^\s*\*\s*$/
				or $worddf =~ /^\s*\>\s*$/
				or $worddf =~ /^\s*\<\s*$/
				or $worddf =~ /^\s*\{\s*$/
				or $worddf =~ /^\s*\}\s*$/
				or $worddf =~ /^\s*\&\s*$/ ){
				#print OUT "\t(PUNC ".REMOVEMARKSPUNC($worddf).")\n";
				if ($do_replace_puncs){
					$to_print .= "\t(PUNC ".REMOVEMARKSPUNC($worddf).")\n";
				}
				else{
					$to_print .= "\t(PUNC ".$worddf.")\n";
				}
				
				print LOG "NOSOL\tPUNC $worddf\n";
				$tagmorphs{"PUNC"}{$worddf} =1;
				
			}
			else{
				$numunknown++;
				#print OUT "\t(NNP ".REMOVEMARKSWORD($word).")\n";
				#print LOG "NOSOL\t", REMOVEMARKSWORD($word),"\n";
				if ($use_nnp_heur){
					$to_print .= "\t(NNP ".$word.")\n";
				}
				else{
					$to_print .= "\t(OOV ".$word.")\n";
				}
				#print LOG "NOSOL\t", $word,"\n";
				$tagmorphs{"OOV"}{$word} =1;
			}
		}
		
		if ($isendsen){
			print STDERR "Finished processing sentence: $sentencenum\r";
			$to_print .= "#\n";
			$sentencenum++;
		}
		
		#some corrections
		if ($whichatb ==2 and $sentencenum == 26 and $word eq ">xyrA"){
			$to_print .= "_\n\t\(PUNC _)\n";
			#print STDERR "\n\n";
			$numstrings++;
			$numotherstrings++;
		}
		
		if ($whichatb ==2 and $sentencenum == 412 and $word eq "l"){
			$to_print .= "_\n\t\(PUNC _)\n";
			#print STDERR "\n\n";
			$numstrings++;
			$numotherstrings++;
		}
		
		if ($whichatb ==2 and $sentencenum == 1539 and $word eq "SydA"){
			$to_print .= "_\n\t\(PUNC _)\n";
			#print STDERR "\n\n";
			$numstrings++;
			$numotherstrings++;
		}
		
		
		
			
		}#end if INPUT
		
	}

print STDERR "\n";

=old
#print the statistics
print LOG	"#Strings   : $numstrings\n",
          "#Arabic    : $numarabicstrings\n",
          "#Other     : $numotherstrings\n",
			    "#OOV       : $numunknown\n",			
			    "Ambig Words: ",$numambiguouswords/$numarabicstrings,"\n",
			    "Uncollapsed: ",$numuncollapsed/$numanalyses,"\n",
			    "No Correct : $numnotchosensol\n";

foreach my $tag (sort keys %tagmorphs){
	print LOG "$tag ";
}
print LOG "\n\n";


print LOG "##################TAGMORPHS###############\n";
foreach my $tag (sort keys %tagmorphs){
	print LOG "$tag\n";
	print LOG "\t";
	if (length keys %{ $tagmorphs{$tag} } > 500){
		print LOG ">100";
		next;
	}
	foreach my $morph (keys %{ $tagmorphs{$tag} } ){
		print LOG "$morph ";
	}
	print LOG "\n";
}


my ($sum,$msum)=(0,0);
foreach my $numanal (sort keys %numanalyses_numwords){
	$sum+=max(1,$numanal)*$numanalyses_numwords{$numanal};$msum+=$numanalyses_numwords{$numanal};
	print LOG "$numanal anlyses: $numanalyses_numwords{$numanal}\n";
}
print LOG "average analyses:",$sum/$msum,"\n";


my ($sum,$msum) = (0,0);
foreach my $numseg (sort keys %numsegments_numwords){
	$sum+=$numseg*$numsegments_numwords{$numseg};$msum+=$numsegments_numwords{$numseg};
	print LOG "words with $numseg different segments: $numsegments_numwords{$numseg}\n";
}
print LOG "average number of different segments per word:",$sum/$msum,"\n";


my $sum = 0, $msum=0;
foreach my $numseg (sort keys %numsegments_numanal){
	$sum+=max(1,$numseg)*$numsegments_numanal{$numseg};$msum+=$numsegments_numanal{$numseg};
	print LOG "$numseg segments: $numsegments_numanal{$numseg}\n";
}
print LOG "average segments:",$sum/$msum,"\n";

close(OUT);
close(LOG);
close(BUCKBT);
=cut

return $to_print;

}



#########################################################


##########################################################
sub SplitTXT{

my $buckout = shift;
my @new = ();

my $p = 1;
my $tmp = "";

while ($_ = shift @$buckout) {
    #chop;

		if (/^\s*\#\s*$/) {
			push @new, "#";
			next;
		}
    elsif (/^INPUT STRING: (.*)/) {
		#s/\xd8\x8c/ZZZ/g;
		#s/\xA1/,/g;
		#s/\xBF/?/g;
		$_ = HEX_TO_CHAR($_);
        if (/[\xa0-\xfe]/) {
			#s/ZZZ/\xd8\x8c/g;
			$p = 1;
		}
		else {
			$p = 0;
			$tmp = $_;
			$tmp =~ s/^INPUT STRING: //g;
			#7.12.07.11.35
			#added ".," here, and commented out the lines below
			$tmp =~ s/([\!\@\#\$\%\^\&\*\(\)\-\+\_\=\|\\\;\:\"\'\{\}\[\]\~\`\<\>\?\/\.,])/ $1 /g;
			$tmp =~ s/^\s+//g;
			$tmp =~ s/\s+$//g;
			#$tmp =~ s/ZZZ$/ ZZZ/g;
			#$tmp =~ s/(\d+)\.\s+/$1 . /g;
			#$tmp =~ s/(\d+)\.$/$1 ./g;
			#$tmp =~ s/\.(\d+)/.$1 /g;
			#$tmp =~ s/\s+$//g;
			#$tmp =~ s/([a-zA-Z])\./$1 ./g;
			#$tmp =~ s/\.([a-zA-Z])/. $1/g;
			#$tmp =~ s/\s\.\.(\d+)/ . .$1/g;
			#$tmp =~ s/\s\.\.\.(\d+)/ ... $1/g;
			#$tmp =~ s/\,\./, ./g;
			#$tmp =~ s/(\w+)\,\s+/$1 , /g;
			#$tmp =~ s/ZZZ/\xd8\x8c/g;
			$tmp =~ s/\s+/ /g;
			foreach my $i (split(" ", $tmp)) {
				# print "token: $i to be considered\n";
				push @new, "INPUT STRING: $i";
				$_ = $i;
				if ((/^\d+$/) or (/^\d+[\,\.]\d+$/) or (/^\d+\xd8\x8c\d+$/) or (/^\.\d+$/)) {
					push @new,  "     Comment: NUMERICAL";
					$i =~ s/\xd8\x8c/:/g;
					push @new, "* SOLUTION 1: () $i/NUM";
					push @new, "1";
				} else {
					if (/[A-Za-z]/) {
					push @new,  "     Comment: NON_ALPHABETIC_DATA";
					push @new,  "* SOLUTION 1: () $i/NON_ARABIC";
					push @new,  "1";
					} else {
					push @new,  "     Comment: PUNCTUATION";
					$i =~ s/\xd8\x8c/,/g;
					push @new,  "* SOLUTION 1: () $i/PUNC";
					push @new,  "1";
					}
				}
			}
		}
    }
    
    if ($p == 1) {
		push @new,  "$_";
    }
}

print STDERR "new in SplitTXT\n";
print STDERR join("\n",@new);

return @new;

}
#end SplitTXT




#########################################################

sub is_lemma_morph(){
	my ($lemma,$tagmorph,$analysis,$do_collapse,$tagmorphs) = @_;
	
	if (scalar(@$tagmorphs)==1){
		return 1;
	}
	
	$lemma =~ s/\[|\]//g;
	$lemma =~ s/_.+$//;
	
	$tagmorph =~ /^\((.+) (.+)\)$/;
	my ($tag,$morph) = ($1,$2);
	$morph =~ s/\(nll\)//;
	$morph =~ s/\(null\)//;
	chop $morph;	#!
	my $mtag = MATCH_TAG($tag);
				
	#if the tag is significant (noun, verb...) then it has a lemma
	if ( ($do_collapse and STR_PIN_LIST($mtag,\@SIGTAGSCOLL) )
		 or (!$do_collapse and STR_PIN_LIST($mtag,\@SIGTAGS) ) ){
		return 1;
	}
	
	#the tag is not significant: if there is no significant tags in the rest of the word
	#then check if the morph is contained in the lemma, then it has a lemma
	if ( ( ($do_collapse and !STR_PIN_LIST($analysis,\@SIGTAGSCOLL) )
		   or (!$do_collapse and !STR_PIN_LIST($analysis,\@SIGTAGS) ) ) 
		and ($lemma =~ /\Q$morph\E/ or $morph=~/\Q$lemma\E/
			   or (scalar(@$tagmorphs)==2 and $tagmorph eq $$tagmorphs[1])
			   or (scalar(@$tagmorphs)>2 and $tagmorph ne $$tagmorphs[0] and $tagmorph ne $$tagmorphs[scalar(@$tagmorphs)]) )
		#and ($lemma =~ /\Q$morph\E/ or $morph=~/\Q$lemma\E/
		#	 or $mtag=~/PRON/) 
		){
		return 1;
	}
	
	return 0;
}


###########################################################

sub max{
	my ($a,$b) = @_;
	return ($a>$b)?$a:$b;
}

##########################################################
sub num_diff_seg{
	my @solutions = @_;
	return 1 if @solutions==0;
	my %hash = ();
	foreach my $solution (@solutions){
		my @morphs = ($solution =~ /\(.+? (.+?)\)/g);
		my $morphs = join(" ",@morphs);
		$hash{$morphs} = 1;
	}
	my @hash = keys %hash;
	return @hash;
}

#################################################################

sub REMOVEMARKS{
	my ($word,$isarabic) = @_;
	
	if ($isarabic) {
		return REMOVEMARKSWORD($word);
	}
	else {
		return REMOVEMARKSPUNC($word);
	}
}



#################################################################

#make all the formats the same so we can match
sub def_format{
	my ($word) = @_;
#	$word =~ s/\{/A/g;	
#	$word =~ s/Y/y/g;	
#	$word =~ s/p/t/g;	
#	$word =~ s/\</A/g;	
#	$word =~ s/\>/A/g;	
#	$word =~ s/Y'/\}/g;	
#	$word =~ s/y'/\}/g;	
#	$word =~ s/w'/\&/g;
	
	$word =~ s/\xA1/\,/g;	
	$word =~ s/\xD8\x8C/\,/g;
	$word =~ s/\xBF/\?/g;
	#$word =~ s/\x1F\x06/\?/g;
	$word =~ s/\xD8\x9F/\?/g;
	$word =~ s/\xDC/\_/g;
	$word =~ s/\xF6/\_/g;	#atb2
	$word =~ s/\xD9\x80/\_/g;
	$word =~ s/\xD9\x8B/\_/g;
	return $word;
}
#################################################################


sub hextopunc {
	my $word = shift;	
	
	$word =~ s/\xA1/\,/g;	#atb3
	$word =~ s/\xBF/\?/g;	#atb3
	$word =~ s/\xDC/\_/g;
	$word =~ s/\xF0/r/g;	#atb3, F0 is a noncharacter in utf8
	return $word;
}


#################################################################

sub check_ambig_sol{
	my @solutions = @_;
	my $isambig = 0;
	for(my $i=0;$i<@solutions;$i++){
		for(my $j=$i+1;$j<@solutions;$j++){
			my @tagsi = ($solutions[$i] =~ /\((.+?) .+?\)/g);
			my $tagsi = join(" ",@tagsi);
			my @tagsj = ($solutions[$j] =~ /\((.+?) .+?\)/g);
			my $tagsj = join(" ",@tagsj);
			if ($tagsi eq $tagsj){
				#print ERROR "ambiguity with tags: $solutions[$i] -- $solutions[$j]\n";
				$isambig = 1;
			}
		}
	}
	
	return $isambig;
}


################################################################



sub get_tags_morphs{
	my ($line) = @_;

	$line ='+'.$line.'+';
	my @tags = ($line =~ /\/([^\/]+?)\+/g);	#match tags which comes after /
	my $tags = join("+",@tags);
	my @morphs = ($line =~ /\+(.+?)\//g);
	my $morphs = join("",@morphs);
	
	$morphs =~ s/[aiueo~`FNK]//g if !($tags eq 'NON_ARABIC' or $tags eq 'PUNC' or $tags eq 'NUM');	#remove vowels
	
	return ($tags,$morphs);
}


###################################################


=OLD	

sub perform_auto_sep_new{
	my ($line,$tagmorphs) = @_;
	
	my $num_parts = 0;
	$line ='+'.$line.'+';
	my @tags = ($line =~ /\/([^\/]+?)\+/g);	#match tags which comes after /
	my @morphs = ($line =~ /\+(.+?)\//g);
	print STDERR "num tags!= num morphs: $line\n" and exit if (@tags != @morphs);
	
	my $size = @tags; my $last = "";
	for (my $j=$size-1; $j>=0; $j--){
		if ($tags[$j]=~/PVSUFF_[^D]/ and $last ne "PVSUFF"){
			print STDERR "PVSUFF at the begin of: $line\n" and exit if $j==0;
			$tags[$j-1] .= "+$tags[$j]";
			$morphs[$j-1] .= "+$morphs[$j]";
			delete $tags[$j];
			delete $morphs[$j];
			$last = "PVSUFF";
		}
		elsif ($tags[$j]=~/IVSUFF_[^D]/ and $last ne "IVSUFF"){
			print STDERR "IVSUFF at the begin of: $line\n" and exit if $j==0;
			$tags[$j-1] .= "+$tags[$j]";
			$morphs[$j-1] .= "+$morphs[$j]";
			delete $tags[$j];
			delete $morphs[$j];
			$last = "IVSUFF";
		}
		elsif ($tags[$j]=~/CVSUFF_[^D]/ and $last ne "CVSUFF"){	#atb2 only
			print STDERR "CVSUFF at the begin of: $line\n" and exit if $j==0;
			$tags[$j-1] .= "+$tags[$j]";
			$morphs[$j-1] .= "+$morphs[$j]";
			delete $tags[$j];
			delete $morphs[$j];
			$last = "CVSUFF";
		}
		elsif ($tags[$j]=~/NSUFF/ and $last ne "NSUFF"){
			print STDERR "NSUFF at the begin of: $line\n" and exit if $j==0;
			$tags[$j-1] .= "+$tags[$j]";
			$morphs[$j-1] .= "+$morphs[$j]";
			delete $tags[$j];
			delete $morphs[$j];
			$last = "NSUFF";
		}
		elsif ($tags[$j]=~/CASE/ and $last ne "CASE"){ #atb2 only doesn't appear in atb1
			print STDERR "CASE at the begin of: $line\n" and exit if $j==0;
			$tags[$j-1] .= "+$tags[$j]";
			$morphs[$j-1] .= "+$morphs[$j]";
			delete $tags[$j];
			delete $morphs[$j];
			$last = "CASE";
		}#the following comes before
		elsif ($tags[$j] eq "DET" and $last ne "DET"){
			next if $j==@tags-1;
			$tags[$j] .= "+".$tags[$j+1];
			$morphs[$j] .= "+".$morphs[$j+1];
			delete $tags[$j+1];
			delete $morphs[$j+1];
			$last = "DET";
		}
		elsif ($tags[$j]=~/IV\d/ and $last ne "IVn"){
			print STDERR "IV[1-3] no one after: $line\n" and exit if $j==@tags-1;
			$tags[$j] .= "+".$tags[$j+1];
			$morphs[$j] .= "+".$morphs[$j+1];
			delete $tags[$j+1];
			delete $morphs[$j+1];
			$last = "IVn";
		}
		elsif ($tags[$j] eq "FUT" and $last ne "FUT"){
			print STDERR "FUT no one after: $line\n" and exit if $j==@tags-1;
			$tags[$j] .= "+".$tags[$j+1];
			$morphs[$j] .= "+".$morphs[$j+1];
			delete $tags[$j+1];
			delete $morphs[$j+1];
			$last = "FUT";
		}
		elsif ($tags[$j] eq "SUBJUNC" and $whichatb == 2  and $last ne "SUBJUNC"){ #atb2 only
			print STDERR "SUBJUNC no one after: $line\n" and exit if $j==@tags-1;
			$tags[$j] .= "+".$tags[$j+1];
			$morphs[$j] .= "+".$morphs[$j+1];
			delete $tags[$j+1];
			delete $morphs[$j+1];
			$last = "SUBJUNC";
		}
	}
	
	for(my ($i,$j)=(0,0); $i<@tags; $i++){		
		@$tagmorphs[$j++] = "($tags[$i] $morphs[$i])" if defined($tags[$i]);
	}
}



#############################################


sub perform_auto_sep{
	my ($line,$tagmorphs) = @_;
	
	my $num_parts = 0;
	
	#"^([^/]*)(/SUBJUNC\s*)\+\s*(.*)$"
	$match = ($line =~ /^([^\/]*)\/(SUBJUNC\s*)\+\s*(.*)$/);
	if ($match){
		my $morph = $1, $tag = $2;
		$line = $3;
		$morph =~ s/[aiueo~\+`FNK\-]//g;
		print ERRER "EMPTY MORPHEME, sen# $sentencenum: tag=($tag)\n$line" and exit if $morph eq "";# $morph = "*V*" if $morph eq "";	#check if because of removing the vowels no morpheme left, this should never happen
		@$tagmorphs[$num_parts++] = "($tag $morph)";			
	}
							
	#"^([^/]*)(/PREP\s*)\+\s*(.*)$"#
	$match = ($line =~ /^([^\/]*)\/(PREP\s*)\+\s*(.*)$/);
	if ($match){
		my $morph = $1, $tag = $2;
		$line = $3;
		$morph =~ s/[aiueo~\+`FNK\-]//g;
		print ERRER "EMPTY MORPHEME, sen# $sentencenum: tag=($tag)\n$line" and exit if $morph eq "";# $morph = "*V*" if $morph eq "";	#check if because of removing the vowels no morpheme left, this should never happen
		@$tagmorphs[$num_parts++] = "($tag $morph)";			
	}
	
	#"^([^/]*)(/FUNC_WORD\s*)\+\s*(.*)$"
	$match = ($line =~ /^([^\/]*)\/(FUNC_WORD\s*)\+\s*(.*)$/);
	if ($match){
		my $morph = $1, $tag = $2;
		$line = $3;
		$morph =~ s/[aiueo~\+`FNK\-]//g;
		print ERRER "EMPTY MORPHEME, sen# $sentencenum: tag=($tag)\n$line" and exit if $morph eq "";# $morph = "*V*" if $morph eq "";	#check if because of removing the vowels no morpheme left, this should never happen
		@$tagmorphs[$num_parts++] = "($tag $morph)";			
	}
	
	#"^([^/]*)(/CONJ\s*)\+\s*(.*)$"
	$match = ($line =~ /^([^\/]*)\/(CONJ\s*)\+\s*(.*)$/);
	if ($match){
		my $morph = $1, $tag = $2;
		$line = $3;
		$morph =~ s/[aiueo~\+`FNK\-]//g;
		print ERRER "EMPTY MORPHEME, sen# $sentencenum: tag=($tag)\n$line" and exit if $morph eq "";# $morph = "*V*" if $morph eq "";	#check if because of removing the vowels no morpheme left, this should never happen
		@$tagmorphs[$num_parts++] = "($tag $morph)";			
	}
	
	#"^([^/]*)(/SUBJUNC\s*)\+\s*(.*)$"
	$match = ($line =~ /^([^\/]*)\/(SUBJUNC\s*)\+\s*(.*)$/);
	if ($match){
		my $morph = $1, $tag = $2;
		$line = $3;
		$morph =~ s/[aiueo~\+`FNK\-]//g;
		print ERRER "EMPTY MORPHEME, sen# $sentencenum: tag=($tag)\n$line" and exit if $morph eq "";# $morph = "*V*" if $morph eq "";	#check if because of removing the vowels no morpheme left, this should never happen
		@$tagmorphs[$num_parts++] = "($tag $morph)";			
	}
						
	#"^([^/]*)(/PREP\s*)\+\s*(.*)$"#
	$match = ($line =~ /^([^\/]*)\/(PREP\s*)\+\s*(.*)$/);
	if ($match){
		my $morph = $1, $tag = $2;
		$line = $3;
		$morph =~ s/[aiueo~\+`FNK\-]//g;
		print ERRER "EMPTY MORPHEME, sen# $sentencenum: tag=($tag)\n$line" and exit if $morph eq "";# $morph = "*V*" if $morph eq "";	#check if because of removing the vowels no morpheme left, this should never happen
		@$tagmorphs[$num_parts++] = "($tag $morph)";			
	}
	
	#"^([^/]*)(/[^\+]*PART[^\+]*\s*)\+\s*(.*)$"
	$match = ($line =~ /^([^\/]*)\/([^\+]*PART[^\+]*\s*)\+\s*(.*)$/);
	if ($match){  # and $line !~ /^([^\/]*)\/(NEG\_PART[^\+]*\s*)\+\s*(.*PVSUFF\_SUBJ\:3MS)$/){
		my $morph = $1, $tag = $2;
		$line = $3;
		$morph =~ s/[aiueo~\+`FNK\-]//g;
		print ERRER "EMPTY MORPHEME, sen# $sentencenum: tag=($tag)\n$line" and exit if $morph eq "";# $morph = "*V*" if $morph eq "";	#check if because of removing the vowels no morpheme left, this should never happen
		@$tagmorphs[$num_parts++] = "($tag $morph)";			
	}
	
	#"^(.*)(\/[^\/]*)(\+[^\+]*\/[^\/]*PRON[^\+\s]*.*)$"
	$match = ($line =~ /^(.*)(\/[^\/]*)\+([^\+]*)\/([^\/]*PRON[^\+\s]*.*)$/);
	if ($match){
		my $morph = $3, $tag = $4;
		$line = $1.$2;

		#we need to analyze the line because it comes before the rest
		my ($tags,$morphs) = get_tags_morphs($line);
		
		@$tagmorphs[$num_parts++] = "($tags $morphs)";
		
		$line ="";
		
		$morph =~ s/[aiueo~\+`FNK\-]//g;  #this is not punc for sure
		print ERRER "EMPTY MORPHEME, sen# $sentencenum: tag=($tag)\n$line" and exit if $morph eq "";# $morph = "*V*" if $morph eq "";	#check if because of removing the vowels no morpheme left, this should never happen
		@$tagmorphs[$num_parts++] = "($tag $morph)";			
	}

	#"^(.*)(\/[^\/]*)(\+[^\+]*\/[^\/]*_DO[^\+\s]*.*)$"
	$match = ($line =~ /^(.*)(\/[^\/]*)\+([^\+]*)\/([^\/]*_DO[^\+\s]*.*)$/);
	if ($match){
		my $morph = $3, $tag = $4;
		$line = $1.$2;
		
		my ($tags,$morphs) = get_tags_morphs($line);
		
		@$tagmorphs[$num_parts++] = "($tags $morphs)";
		
		$line ="";
		
		$morph =~ s/[aiueo~\+`FNK\-]//g;	#this is not punc for sure
		print ERRER "EMPTY MORPHEME, sen# $sentencenum: tag=($tag)\n$line" and exit if $morph eq "";# $morph = "*V*" if $morph eq "";	#check if because of removing the vowels no morpheme left, this should never happen
		@$tagmorphs[$num_parts++] = "($tag $morph)";			
	}
	
	if ($num_parts == 0 || $line ne ""){
		my ($tags,$morphs) = get_tags_morphs($line);
		
		$morphs =~ s/[aiueo~`FNK]//g if !($tags eq 'NON_ARABIC' or $tags eq 'PUNC' or $tags eq 'NUM');	#remove vowels
		if ($morphs ne ''){
			@$tagmorphs[$num_parts++] = "($tags $morphs)";
		}
		else{
			print ERRER "EMPTY MORPHEME, sen# $sentencenum: tag=($tag)\n$line" and exit if $morph eq "";# $morph = "*V*" if $morph eq "";	#check if because of removing the vowels no morpheme left, this should never happen
		}
	}
	
}



=cut
