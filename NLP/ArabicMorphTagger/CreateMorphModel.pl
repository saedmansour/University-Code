#!/usr/bin/perl -w


use strict;



use lib ".";

use CorpusProbabilities;
use MorphTranslation;
use LM;


###################################
#13.11.06
#by Saib
#corpus.morph.lm is generated with additional ngrams that are generated
#because of the svm analyses. If I want to generate the same file as before
#the analyses that belong to the svm should be discarded in OutputLM.
#
#created two new files analyses.morph.map.svm and analyses.morph.revmap.svm
#which includes the svm analyses.
#
#in case of multiple parses leave the most probable one, causes non-svm to become
#svm if the difference is only in the morph, [TODO]should ask roy why he did that,
#maybe he had errors in disambiguation later?!
###################################
#corpus.morph.lm analyses.morph joined-atb1-dev-analyses-roy.coll.match.nnp-atb1-dev-gold-seg-without-vowel.match.POS.MT corpus.lm corpus.lex.prob 0 1

########################### Main program #####################################

my $outputlmname = $ARGV[0];	#corpus.morph.lm
my $outputmapname = $ARGV[1];
my $testparses = $ARGV[2];
my $langmodel  = $ARGV[3];	#corpus.lm
my $lexprobfile = $ARGV[4];
my $remove_corpus_analyses = $ARGV[5];
my $inc_svm = $ARGV[6];
#10.11
#we use static values for analyses not found in the corpus, or analyses from 
#the SVM model. Should be generated by something like:
#P(m,t) = K1*Pmac(m,t)+K2*1/|tags(m)|+K3*Paac(m,t)
#(mac = manually annotated corpus, aac = automatically annotated corpus (ambiguous corpus))
#K1 should be big so that the model won't be changed drastically

my $lowprob = 1e-10;	#(m,t) not in annotated corpus but in analyses
my $probsvm = 1e-10;	#(w,t) from SVM model

#given to morphemes which are taged with tags not seen neither in the corpus, 
#nor in the ambiguous corpus if present
my $verylowprob =1e-40;

my $with_sublexicon;

#read the morpheme tag sequence language model generated by ngram-count over the 
#tags of the corpus, updates %LM in LM.pl.
ReadLM($langmodel);

#while (<STDIN>) {
#  chomp;
#  printf STDERR "Log prob is: %e\n",SequenceProb($_ . ' </s>',3,'<s>');
#}
#exit;

print STDERR "Retrieving counted corpus...\n";
#updates in CorpusProbabilities.pm counts of words and analyses
RetrieveCountCorpus($lexprobfile);

if (%PROBGCATS) {
  print STDERR "ambiguous corpus is specified\n";
  $with_sublexicon = 1;
}
else { 
  print STDERR "no ambiguous corpus\n";
  $with_sublexicon = 0;
}


my @NGRAMS = ();
my @SENT_NGRAMS = ();
my $N=3;

############### converting test parses file  into an SRILM map-text file ##############

my $knownpairs = 0;
my $unknownpairs = 0;

my $outmap = $outputmapname . ".map";
my $reversemapping = $outputmapname. '.revmap';

print STDERR "Creating map file...\n";


my $BOS = 1;
open(TP,"<" . $testparses) or die "Can't open $testparses\n";

open(OM,">" . $outmap) or die "Can't open $outmap for output\n"; 
open(RM,">" . $reversemapping) or die "Can't open $reversemapping\n"; 
if ($inc_svm){
	open(OMSVM,"> $outmap\.svm") or die "Can't open $outmap\.svm for svm output\n"; 
	open(RMSVM,"> $reversemapping\.svm") or die "Can't open $reversemapping\.svm\n"; 
}

my %analyses = ();
my %parses = ();
my %parses_of_analyses = ();
my $word;
while (<TP>) {
  # end of sentence was reached, output end-of-sentence symbol
  if (/#/) {
    $knownpairs++ unless ($word =~ /\?/); # for dots at end-of-sentence that were removed 
    PrintMapLine();
    
	PrintOM("</s> </s>\n","</s> </s>\n");
	
	AddNgramsToLM(keys %analyses);
    $word = "end-of-sentence";  # for debugging purpose only
    AddNgramsToLM("</s>");
    $BOS =1;
    next;
  } 
  
  #28.9.07
  #DALIA
  if (/^\s*\<\/paragraph\>\s*$/){
	  PrintOM("</p> </p>\n","");
	  next;
  }	  
  
  
  chomp;
  s/^\s+//;
  s/\s+$//; 
  #s/yy//g;
  #s/ \S*?\d+\S*?\)/ NUM\)/g;
  unless (/\S+\s+\S+/) { # it's a word
    if ($BOS) {
      ClearNgrams();
      $word = "beginning-of-sentence";  # for debugging purpose only
      %analyses = ("<s>",1); 
      PrintOM("<s> <s>\n","<s> <s>\n");
	  $BOS = 0;
     }      
    else {
      PrintMapLine();
    }

    if (%analyses) {
      AddNgramsToLM(keys %analyses);
    }  
    $word = $_;
    PrintOM($word,"");
	
    # add all the analyses that exist in the corpus for this word
	#The analysis from the learning corpus are added here
    %parses = ();
    %analyses = ();
    %parses_of_analyses = ();
	#should be removed and done externally
	#print STDERR "CreateMorphModel.pl Ln127: remove_corpus_analyses=$remove_corpus_analyses\n";
	if ($remove_corpus_analyses eq "0"){
		foreach my $parse (keys %{$GPARSES{$word}}) {
			next if defined($parses{$parse});     
			$parses{$parse} = 1;
			my $analysis = ParseToTagSequence($parse);      
			$analysis =~ s/ /_/g;    
		      
			#caclculating P(word|analysis) = P(m1|t1)*P(m2|t2)*...*P(mn|tn)
			my $prob = MorphLexProb($parse);

			#in case of multiple parses per analysis, keep the most probable one
			if (defined($analyses{$analysis})) {
		#        print STDERR "more than one parse for $word has the same analysis $analysis\n";
		#        printf STDERR "CORPUS:comparing <%s,%e> (current) with <%s,%e> (new)\n",
		#	    $parses_of_analyses{$analysis}{"parse"},
		#	    $parses_of_analyses{$analysis}{"prob"},
		#            $parse,
		#	    $prob;

				if ($prob > $parses_of_analyses{$analysis}{"prob"}) {          
		#          print STDERR "CORPUS:replacing\n";
				$parses_of_analyses{$analysis}{"parse"}=$parse;
				$parses_of_analyses{$analysis}{"prob"}=$prob;
				}
			}
			# it's the first time the analysis was seen - save the parse and the probability
			else {
				$parses_of_analyses{$analysis}{"parse"}=$parse;
				$parses_of_analyses{$analysis}{"prob"}=$prob;        
				$analyses{$analysis} =1;
			}
		}
	}
  }
  else { # it's a parse
	my $svm = 0;
    my $parse = $_;
	if ($parse =~ /^(\(.+\))\s+__SVM__\s*$/){
		$parse = $1;
		$svm = 1;
	}
    next if defined ($parses{$parse});     
    $parses{$parse} = 1;
    my $analysis = ParseToTagSequence($parse);
    $analysis =~ s/ /_/g;    
 
    #caclculating P(word|analysis) = P(m1|t1)*P(m2|t2)*...*P(mn|tn)
    my $prob = MorphLexProb($parse);
	#update the probability in case of svm, maybe should be done in MorphLexProb to deal with each morph
	if ($svm){
		#$prob+=1/(|buck(m)|+1)/svm(m);
	}
	
    #in case of multiple parses per analysis, keep the most probable one
    if (defined($analyses{$analysis})) {
#      print STDERR "more than one parse for $word has the same analysis $analysis\n";
#       printf STDERR "comparing <%s,%e> (current) with <%s,%e> (new)\n",
#	    $parses_of_analyses{$analysis}{"parse"},
#	    $parses_of_analyses{$analysis}{"prob"},
#            $parse,
#	    $prob;
      if ($prob > $parses_of_analyses{$analysis}{"prob"}) {
#        print STDERR "replacing\n";
        $parses_of_analyses{$analysis}{"parse"}=$parse;
        $parses_of_analyses{$analysis}{"prob"}=$prob;
		$parses_of_analyses{$analysis}{"svm"}=1 if $svm;
      }
    }
    # it's the first time the analysis was seen - save the parse and the probability
    else {
       $parses_of_analyses{$analysis}{"parse"}=$parse;
       $parses_of_analyses{$analysis}{"prob"}=$prob;        
	   $parses_of_analyses{$analysis}{"svm"}=1 if $svm;
       $analyses{$analysis} =1;
    }
  }
}     

close(OM);
close(RM);
if ($inc_svm){
	close(OMSVM);
	close(RMSVM);
}

unless ($with_sublexicon) {
  printf STDERR "known morph-tag pairs %d (%f6.2), unknown pairs %d (%f6.2)\n",
     $knownpairs,  100*$knownpairs  /($knownpairs+$unknownpairs),
     $unknownpairs,100*$unknownpairs/($knownpairs+$unknownpairs);
}

# output language model
OutputLM($langmodel);

################################# end of main program ##################################3

sub OutputLM {
  #open output lm corpus.morph.lm
  open(CMLM,">" . $outputlmname) 
    or die "Can't open $outputlmname for output\n"; 
  
  #print header
  print CMLM "\n\\data\\\n"; 
  my $n = $#NGRAMS;
  for (my $i=0;$i<=$n;$i++) {
      printf CMLM "ngram %d=%d\n",$i+1,scalar(keys %{$NGRAMS[$i]});
  }

  print CMLM "\n";

  for (my $i=0;$i<=$n;$i++) {
      printf CMLM "\\%d-grams:\n",$i+1;
      my $ngram;  
      foreach $ngram (sort keys %{$NGRAMS[$i]}) {
	if ($i<$n) {
          printf CMLM "%-10.6f $ngram -99\n",$NGRAMS[$i]{$ngram},$ngram;
        }
        else {
          printf CMLM "%-10.6f $ngram\n",$NGRAMS[$i]{$ngram},$ngram;
        } 
      }
      print CMLM "\n";
       
  }
  print CMLM "\\end\\\n"; 
  
}
sub ToMorphSeq {
  my $ngram = shift;
  $ngram =~ s/_\]//g;
  $ngram =~ s/\[_//g;
  $ngram =~ s/_/ /g;
  return $ngram;
}

#SequenceProb is imported from LM.pm, calculates prob from lm
sub GetNgramProb {
  my $ngram = shift;
  my $morph_ngram;
  $ngram =~ s/\s*(\S+)$//;
  $morph_ngram = $1;
  $ngram = ToMorphSeq($ngram);
  $morph_ngram = ToMorphSeq($morph_ngram);
#  print STDERR "{$ngram} {$morph_ngram}\n";
  return SequenceProb($morph_ngram,$N,$ngram);
}

#$NGRAMS is local  
sub AddNgram {
  my ($ngram,$order) = @_;
  my $prob; 
  unless (defined($NGRAMS[$order]{$ngram})) {
    $prob = GetNgramProb($ngram); 
    $prob = -99 if $prob <= -99;
    $NGRAMS[$order]{$ngram} = $prob;

    # add the prefix of the n-gram as well
    AddNgram(RemoveLast($ngram),$order-1) if $order;
  } 
#  printf STDERR "%s : logprob = %f\n",$ngram,$NGRAMS[$order]{$ngram};
  

}

sub ClearNgrams {
#  print STDERR "Cleared!\n";
  @SENT_NGRAMS = ();
}

#$SENT_NGRAMS is local
sub AddNgramsToLM {
#  print STDERR "########################### $word ############################\n";
  @{$SENT_NGRAMS[scalar(@SENT_NGRAMS)]} = @_;
  foreach my $ngram (GetAllNgrams($#SENT_NGRAMS)) {
    AddNgram($ngram,$#SENT_NGRAMS);
  }
#  printf STDERR "--> %d\n",scalar(@SENT_NGRAMS); 
  if (scalar(@SENT_NGRAMS) == $N) {
    shift @SENT_NGRAMS;
  }
}


sub GetAllNgrams {
  my $n=shift;
#  print STDERR "n=$n\n";
  return @{$SENT_NGRAMS[0]} if ($n==0);

  my @outlist = ();
  foreach my $prefix (GetAllNgrams($n-1)) {
    foreach my $suffix (@{$SENT_NGRAMS[$n]}) {
      push @outlist, $prefix . " " . $suffix;
    }
  }
  return @outlist;
}

sub MorphLexProb {
  my $parse = shift;
  my $prob = 1;
  my $pairprob;

  my @mtpairs = ParseToMorphTagPairs($parse); 
  while (@mtpairs) {
    my $tag = shift @mtpairs;
    my $morph  = shift @mtpairs;

    $pairprob = MorphPairLexProb($tag,$morph);
#    return $pairprob if $pairprob <= $lowprob;
    $prob *= $pairprob;
  }        
  return $prob;
}


sub MorphPairLexProb {
  my ($tag,$morph) = @_;

  # if sublexicon is available, use the combined probs.
  #if ($with_sublexicon) {
  if (%PROBGCATS) {
    if (defined($PROBGCATS{$tag})) {
      if (defined($PROBGPAIRS{$tag}{$morph})) {

#       printf OM  " <%s %s %12e %12e> ",$morph,$tag, $PROBGPAIRS{$tag}{$morph} / $PROBGCATS{$tag},$prob;
	  print STDERR "$tag $morph\n" if $morph eq "AT" && $tag =~ "NNT";

       return $PROBGPAIRS{$tag}{$morph} / $PROBGCATS{$tag};
      }

      # the pair does not appear neither in the corpus nor in the sublexicon 
     return $lowprob;
    } 
    # the morpheme tag is unknown - give probability very close to zero
    else {
      printf STDERR "NOTE: zero probability! tag:[$tag]\n"; 
      return $verylowprob;

    } 
  }

  # otherwise, use only the corpus to estimate probabilities
  else {
    if (defined($GPAIRS{$tag}{$morph})) {
      $knownpairs++;
      return $GPAIRS{$tag}{$morph}/$GCATS{$tag} 
    }
    $unknownpairs++;
    return $lowprob;
  }        
      
}

sub PrintMapLine {
  foreach my $analysis (keys %analyses) {
	if ($inc_svm){
		printf OMSVM " %s %12e",$analysis,$parses_of_analyses{$analysis}{"prob"};
		printf RMSVM " %s {%s}",$analysis,$parses_of_analyses{$analysis}{"parse"};
	}
	if (not $parses_of_analyses{$analysis}{"svm"}){
		printf OM " %s %12e",$analysis,$parses_of_analyses{$analysis}{"prob"};
		printf RM " %s {%s}",$analysis,$parses_of_analyses{$analysis}{"parse"};
	}
  }
  
  PrintOM("\n","\n");
  
}


#################################
sub PrintOM{
	my ($om,$rm) = @_;
	print OM $om;
	print RM $rm;
	if ($inc_svm){
		print OMSVM $om;
		print RMSVM $rm;
	}
}

